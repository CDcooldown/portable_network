
// Generated by gencpp from file dmsgs/TeamInfo.msg
// DO NOT EDIT!
// Generated by gencpp from file dmsgs/TeamInfo.msg
// DO NOT EDIT!


#ifndef DMSGS_MESSAGE_TEAMINFO_H
#define DMSGS_MESSAGE_TEAMINFO_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>

namespace dmsgs
{
template <class ContainerAllocator>
struct TeamInfo_
{
  typedef TeamInfo_<ContainerAllocator> Type;

  TeamInfo_()
    : txp_timestamp()
    , recv_timestamp()
    , player_number(0)
    , team_number(0)
    , incapacitated(false)
    , role(0)
    , dest()
    , final_dest()
    , attack_target()
    , time_since_last_kick(0.0)
    , state(0)
    , priority(0)
    , see_ball(false)
    , see_circle(false)
    , see_goal(false)
    , robot_pos()
    , ball_field()
    , ball_global()
    , circle_field()
    , circle_global()
    , goal_field()
    , goal_global()
    , ball_quality(0.0)
    , field_quality(0.0)
    , field_consistency(0.0)
    , gc_connected(false)
    , gc_state(0)
    , gc_state2(0)  {
    }
  TeamInfo_(const ContainerAllocator& _alloc)
    : txp_timestamp()
    , recv_timestamp()
    , player_number(0)
    , team_number(0)
    , incapacitated(false)
    , role(0)
    , dest(_alloc)
    , final_dest(_alloc)
    , attack_target(_alloc)
    , time_since_last_kick(0.0)
    , state(0)
    , priority(0)
    , see_ball(false)
    , see_circle(false)
    , see_goal(false)
    , robot_pos(_alloc)
    , ball_field(_alloc)
    , ball_global(_alloc)
    , circle_field(_alloc)
    , circle_global(_alloc)
    , goal_field(_alloc)
    , goal_global(_alloc)
    , ball_quality(0.0)
    , field_quality(0.0)
    , field_consistency(0.0)
    , gc_connected(false)
    , gc_state(0)
    , gc_state2(0)  {
  (void)_alloc;
    }



   typedef ros::Time _txp_timestamp_type;
  _txp_timestamp_type txp_timestamp;

   typedef ros::Time _recv_timestamp_type;
  _recv_timestamp_type recv_timestamp;

   typedef uint8_t _player_number_type;
  _player_number_type player_number;

   typedef uint8_t _team_number_type;
  _team_number_type team_number;

   typedef uint8_t _incapacitated_type;
  _incapacitated_type incapacitated;

   typedef uint8_t _role_type;
  _role_type role;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _dest_type;
  _dest_type dest;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _final_dest_type;
  _final_dest_type final_dest;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _attack_target_type;
  _attack_target_type attack_target;

   typedef float _time_since_last_kick_type;
  _time_since_last_kick_type time_since_last_kick;

   typedef uint8_t _state_type;
  _state_type state;

   typedef uint8_t _priority_type;
  _priority_type priority;

   typedef uint8_t _see_ball_type;
  _see_ball_type see_ball;

   typedef uint8_t _see_circle_type;
  _see_circle_type see_circle;

   typedef uint8_t _see_goal_type;
  _see_goal_type see_goal;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _robot_pos_type;
  _robot_pos_type robot_pos;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _ball_field_type;
  _ball_field_type ball_field;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _ball_global_type;
  _ball_global_type ball_global;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _circle_field_type;
  _circle_field_type circle_field;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _circle_global_type;
  _circle_global_type circle_global;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _goal_field_type;
  _goal_field_type goal_field;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _goal_global_type;
  _goal_global_type goal_global;

   typedef float _ball_quality_type;
  _ball_quality_type ball_quality;

   typedef float _field_quality_type;
  _field_quality_type field_quality;

   typedef float _field_consistency_type;
  _field_consistency_type field_consistency;

   typedef uint8_t _gc_connected_type;
  _gc_connected_type gc_connected;

   typedef uint8_t _gc_state_type;
  _gc_state_type gc_state;

   typedef uint8_t _gc_state2_type;
  _gc_state2_type gc_state2;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(INACTIVE)
  #undef INACTIVE
#endif
#if defined(_WIN32) && defined(PLAYING)
  #undef PLAYING
#endif
#if defined(_WIN32) && defined(BALL_HANDLING)
  #undef BALL_HANDLING
#endif
#if defined(_WIN32) && defined(PLACING)
  #undef PLACING
#endif
#if defined(_WIN32) && defined(SEARCHING)
  #undef SEARCHING
#endif
#if defined(_WIN32) && defined(INITIALIZING)
  #undef INITIALIZING
#endif
#if defined(_WIN32) && defined(ASSISTING)
  #undef ASSISTING
#endif
#if defined(_WIN32) && defined(LOW_PRIORITY)
  #undef LOW_PRIORITY
#endif
#if defined(_WIN32) && defined(NORMAL_PRIORITY)
  #undef NORMAL_PRIORITY
#endif
#if defined(_WIN32) && defined(HIGH_PRIORITY)
  #undef HIGH_PRIORITY
#endif

  enum {
    INACTIVE = 0u,
    PLAYING = 1u,
    BALL_HANDLING = 2u,
    PLACING = 3u,
    SEARCHING = 4u,
    INITIALIZING = 5u,
    ASSISTING = 6u,
    LOW_PRIORITY = 0u,
    NORMAL_PRIORITY = 1u,
    HIGH_PRIORITY = 2u,
  };


  typedef boost::shared_ptr< ::dmsgs::TeamInfo_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::dmsgs::TeamInfo_<ContainerAllocator> const> ConstPtr;

}; // struct TeamInfo_

typedef ::dmsgs::TeamInfo_<std::allocator<void> > TeamInfo;

typedef boost::shared_ptr< ::dmsgs::TeamInfo > TeamInfoPtr;
typedef boost::shared_ptr< ::dmsgs::TeamInfo const> TeamInfoConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::dmsgs::TeamInfo_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::dmsgs::TeamInfo_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::dmsgs::TeamInfo_<ContainerAllocator1> & lhs, const ::dmsgs::TeamInfo_<ContainerAllocator2> & rhs)
{
  return lhs.txp_timestamp == rhs.txp_timestamp &&
    lhs.recv_timestamp == rhs.recv_timestamp &&
    lhs.player_number == rhs.player_number &&
    lhs.team_number == rhs.team_number &&
    lhs.incapacitated == rhs.incapacitated &&
    lhs.role == rhs.role &&
    lhs.dest == rhs.dest &&
    lhs.final_dest == rhs.final_dest &&
    lhs.attack_target == rhs.attack_target &&
    lhs.time_since_last_kick == rhs.time_since_last_kick &&
    lhs.state == rhs.state &&
    lhs.priority == rhs.priority &&
    lhs.see_ball == rhs.see_ball &&
    lhs.see_circle == rhs.see_circle &&
    lhs.see_goal == rhs.see_goal &&
    lhs.robot_pos == rhs.robot_pos &&
    lhs.ball_field == rhs.ball_field &&
    lhs.ball_global == rhs.ball_global &&
    lhs.circle_field == rhs.circle_field &&
    lhs.circle_global == rhs.circle_global &&
    lhs.goal_field == rhs.goal_field &&
    lhs.goal_global == rhs.goal_global &&
    lhs.ball_quality == rhs.ball_quality &&
    lhs.field_quality == rhs.field_quality &&
    lhs.field_consistency == rhs.field_consistency &&
    lhs.gc_connected == rhs.gc_connected &&
    lhs.gc_state == rhs.gc_state &&
    lhs.gc_state2 == rhs.gc_state2;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::dmsgs::TeamInfo_<ContainerAllocator1> & lhs, const ::dmsgs::TeamInfo_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace dmsgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::dmsgs::TeamInfo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::dmsgs::TeamInfo_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::dmsgs::TeamInfo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::dmsgs::TeamInfo_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::dmsgs::TeamInfo_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::dmsgs::TeamInfo_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::dmsgs::TeamInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "0fa8db565e10f9301a7ef80e8c19c078";
  }

  static const char* value(const ::dmsgs::TeamInfo_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x0fa8db565e10f930ULL;
  static const uint64_t static_value2 = 0x1a7ef80e8c19c078ULL;
};

template<class ContainerAllocator>
struct DataType< ::dmsgs::TeamInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "dmsgs/TeamInfo";
  }

  static const char* value(const ::dmsgs::TeamInfo_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::dmsgs::TeamInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# general info\n"
"time txp_timestamp\n"
"time recv_timestamp\n"
"uint8 player_number\n"
"uint8 team_number\n"
"bool incapacitated\n"
"\n"
"# Behavior info\n"
"uint8 role\n"
"geometry_msgs/Vector3 dest\n"
"geometry_msgs/Vector3 final_dest\n"
"geometry_msgs/Vector3 attack_target\n"
"float32 time_since_last_kick\n"
"# playing state of robot\n"
"uint8 state\n"
"uint8 INACTIVE         = 0\n"
"uint8 PLAYING          = 1\n"
"uint8 BALL_HANDLING    = 2\n"
"uint8 PLACING          = 3\n"
"uint8 SEARCHING        = 4\n"
"uint8 INITIALIZING     = 5\n"
"uint8 ASSISTING        = 6\n"
"\n"
"# priority of current behavior\n"
"uint8 priority\n"
"uint8 LOW_PRIORITY     = 0\n"
"uint8 NORMAL_PRIORITY  = 1\n"
"uint8 HIGH_PRIORITY    = 2\n"
"\n"
"# Vision info\n"
"bool see_ball\n"
"bool see_circle\n"
"bool see_goal\n"
"geometry_msgs/Vector3 robot_pos\n"
"geometry_msgs/Vector3 ball_field\n"
"geometry_msgs/Vector3 ball_global\n"
"\n"
"geometry_msgs/Vector3 circle_field\n"
"geometry_msgs/Vector3 circle_global\n"
"\n"
"geometry_msgs/Vector3 goal_field\n"
"geometry_msgs/Vector3 goal_global\n"
"\n"
"float32 ball_quality\n"
"float32 field_quality\n"
"float32 field_consistency\n"
"\n"
"# GCInfo\n"
"bool gc_connected\n"
"uint8 gc_state\n"
"uint8 gc_state2\n"
"\n"
"================================================================================\n"
"MSG: geometry_msgs/Vector3\n"
"# This represents a vector in free space. \n"
"# It is only meant to represent a direction. Therefore, it does not\n"
"# make sense to apply a translation to it (e.g., when applying a \n"
"# generic rigid transformation to a Vector3, tf2 will only apply the\n"
"# rotation). If you want your data to be translatable too, use the\n"
"# geometry_msgs/Point message instead.\n"
"\n"
"float64 x\n"
"float64 y\n"
"float64 z\n"
;
  }

  static const char* value(const ::dmsgs::TeamInfo_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::dmsgs::TeamInfo_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.txp_timestamp);
      stream.next(m.recv_timestamp);
      stream.next(m.player_number);
      stream.next(m.team_number);
      stream.next(m.incapacitated);
      stream.next(m.role);
      stream.next(m.dest);
      stream.next(m.final_dest);
      stream.next(m.attack_target);
      stream.next(m.time_since_last_kick);
      stream.next(m.state);
      stream.next(m.priority);
      stream.next(m.see_ball);
      stream.next(m.see_circle);
      stream.next(m.see_goal);
      stream.next(m.robot_pos);
      stream.next(m.ball_field);
      stream.next(m.ball_global);
      stream.next(m.circle_field);
      stream.next(m.circle_global);
      stream.next(m.goal_field);
      stream.next(m.goal_global);
      stream.next(m.ball_quality);
      stream.next(m.field_quality);
      stream.next(m.field_consistency);
      stream.next(m.gc_connected);
      stream.next(m.gc_state);
      stream.next(m.gc_state2);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct TeamInfo_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::dmsgs::TeamInfo_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::dmsgs::TeamInfo_<ContainerAllocator>& v)
  {
    s << indent << "txp_timestamp: ";
    Printer<ros::Time>::stream(s, indent + "  ", v.txp_timestamp);
    s << indent << "recv_timestamp: ";
    Printer<ros::Time>::stream(s, indent + "  ", v.recv_timestamp);
    s << indent << "player_number: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.player_number);
    s << indent << "team_number: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.team_number);
    s << indent << "incapacitated: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.incapacitated);
    s << indent << "role: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.role);
    s << indent << "dest: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.dest);
    s << indent << "final_dest: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.final_dest);
    s << indent << "attack_target: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.attack_target);
    s << indent << "time_since_last_kick: ";
    Printer<float>::stream(s, indent + "  ", v.time_since_last_kick);
    s << indent << "state: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state);
    s << indent << "priority: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.priority);
    s << indent << "see_ball: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.see_ball);
    s << indent << "see_circle: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.see_circle);
    s << indent << "see_goal: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.see_goal);
    s << indent << "robot_pos: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.robot_pos);
    s << indent << "ball_field: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.ball_field);
    s << indent << "ball_global: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.ball_global);
    s << indent << "circle_field: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.circle_field);
    s << indent << "circle_global: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.circle_global);
    s << indent << "goal_field: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.goal_field);
    s << indent << "goal_global: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.goal_global);
    s << indent << "ball_quality: ";
    Printer<float>::stream(s, indent + "  ", v.ball_quality);
    s << indent << "field_quality: ";
    Printer<float>::stream(s, indent + "  ", v.field_quality);
    s << indent << "field_consistency: ";
    Printer<float>::stream(s, indent + "  ", v.field_consistency);
    s << indent << "gc_connected: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.gc_connected);
    s << indent << "gc_state: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.gc_state);
    s << indent << "gc_state2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.gc_state2);
  }
};

} // namespace message_operations
} // namespace ros

#endif // DMSGS_MESSAGE_TEAMINFO_H
